#!/usr/bin/env python3

import logging
import os
import sys
import json
import glob
import re
from pathlib import Path
from datetime import datetime
from collections import defaultdict, Counter

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('vulnerability_analysis.log')
    ]
)
logger = logging.getLogger(__name__)
"""
Vulnerability Report Analyzer

This script analyzes vulnerability reports generated by auditgh and produces:
1. List of contributors
2. Projects and their last contribution dates
3. Projects with secrets in code
4. Top 10 vulnerable libraries with KEV, EPSS, and fix status
5. Top 10 recommended remedial actions
"""

import os
import json
import glob
import re
from collections import defaultdict, Counter
from datetime import datetime
from pathlib import Path
import markdown
from bs4 import BeautifulSoup
import requests
from typing import Dict, List, Set, Tuple, Optional

# Configuration
REPORTS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vulnerability_reports')
OUTPUT_FILE = 'vulnerability_analysis_summary.md'

# EPSS API endpoint (example, adjust as needed)
EPSS_API = "https://api.first.org/data/v1/epss"

class VulnerabilityAnalyzer:
    def __init__(self, reports_dir: str):
        self.reports_dir = reports_dir
        self.projects = set()
        self.contributors = set()
        self.project_last_commit = {}
        self.secrets_found = defaultdict(list)
        self.vulnerable_libs = []
        self.remedial_actions = []

    def extract_project_name(self, filepath: str) -> str:
        """Extract project name from file path."""
        return os.path.basename(os.path.dirname(filepath))

    def parse_summary_file(self, filepath: str) -> dict:
        """Parse a summary markdown file and extract relevant information."""
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Basic project info
            project_name = self.extract_project_name(filepath)
            logger.info(f"Processing project: {project_name}")
            
            # Initialize project info
            project_info = {
                'name': project_name,
                'last_commit': None,
                'contributors': set(),
                'secrets': [],
                'vulnerabilities': [],
                'file_path': filepath
            }
            
            # Look for common patterns in markdown
            lines = content.split('\n')
            
            # Look for last commit date
            for line in lines:
                if 'last commit' in line.lower() or 'last updated' in line.lower():
                    # Try to extract date from the line
                    date_str = line.split(':')[-1].strip()
                    try:
                        project_info['last_commit'] = datetime.strptime(date_str, '%Y-%m-%d')
                    except ValueError:
                        pass
                
                # Look for contributors
                if 'contributor' in line.lower() and ':' in line:
                    contributors = line.split(':', 1)[1].strip().split(',')
                    project_info['contributors'].update([c.strip() for c in contributors if c.strip()])
            
            # Look for secrets in gitleaks report
            gitleaks_file = filepath.replace('_summary.md', '_gitleaks.md')
            if os.path.exists(gitleaks_file):
                with open(gitleaks_file, 'r', encoding='utf-8') as f:
                    gitleaks_content = f.read()
                    if 'No secrets found' not in gitleaks_content:
                        project_info['secrets'].append('Secrets found in code')
            
            # Look for vulnerabilities in grype report
            grype_file = filepath.replace('_summary.md', '_grype_repo.md')
            if os.path.exists(grype_file):
                with open(grype_file, 'r', encoding='utf-8') as f:
                    grype_content = f.read()
                    # Count vulnerabilities by type
                    vuln_types = re.findall(r'\| ([A-Za-z0-9-]+)\s+\|', grype_content)
                    project_info['vulnerabilities'] = [v for v in vuln_types if v not in ['TYPE', 'Vulnerability']]
            
            return project_info
            
        except Exception as e:
            logger.error(f"Error parsing {filepath}: {str(e)}")
            return None
        
        # This is a simplified parser - you'll need to adjust based on your actual markdown structure
        for h2 in soup.find_all('h2'):
            if 'last commit' in h2.text.lower():
                date_str = h2.text.split(':')[-1].strip()
                try:
                    project_info['last_commit'] = datetime.strptime(date_str, '%Y-%m-%d')
                except ValueError:
                    pass
            
            # Add more parsing logic for other sections
            
        return project_info

    def collect_data(self):
        """Collect data from all report files."""
        summary_files = glob.glob(f"{self.reports_dir}/**/*_summary.md", recursive=True)
        
        for summary_file in summary_files:
            try:
                project_data = self.parse_summary_file(summary_file)
                self.projects.add(project_data['name'])
                
                if project_data['last_commit']:
                    self.project_last_commit[project_data['name']] = project_data['last_commit']
                
                self.contributors.update(project_data['contributors'])
                
                if project_data['secrets']:
                    self.secrets_found[project_data['name']] = project_data['secrets']
                
                self.vulnerable_libs.extend(project_data.get('vulnerabilities', []))
                
            except Exception as e:
                print(f"Error processing {summary_file}: {str(e)}")
                continue

    def analyze_vulnerabilities(self):
        """Analyze collected vulnerability data."""
        # Count occurrences of each vulnerability type
        vuln_counter = Counter()
        for vuln in self.vulnerable_libs:
            if isinstance(vuln, dict):
                vuln_counter[vuln.get('type', 'unknown')] += 1
            else:
                vuln_counter[str(vuln)] += 1
        
        # Get top 10 most common vulnerabilities
        self.top_vulnerabilities = vuln_counter.most_common(10)
        
        # Generate remedial actions based on vulnerabilities
        self._generate_remedial_actions()

    def _generate_remedial_actions(self):
        """Generate recommended remedial actions based on vulnerabilities."""
        # This is a simplified example - you'd want to customize this based on your actual vulnerabilities
        actions = []
        
        if any('outdated' in vuln.lower() for vuln, _ in self.top_vulnerabilities):
            actions.append("Update all dependencies to their latest secure versions")
        
        if any('secret' in vuln.lower() for vuln, _ in self.top_vulnerabilities):
            actions.append("Rotate all exposed secrets and implement secret management")
        
        if any('xss' in vuln.lower() for vuln, _ in self.top_vulnerabilities):
            actions.append("Implement proper input validation and output encoding")
        
        if any('injection' in vuln.lower() for vuln, _ in self.top_vulnerabilities):
            actions.append("Use parameterized queries and prepared statements")
        
        if any('misconfiguration' in vuln.lower() for vuln, _ in self.top_vulnerabilities):
            actions.append("Review and harden system and application configurations")
        
        self.remedial_actions = actions[:10]  # Limit to top 10

    def generate_report(self) -> str:
        """Generate a markdown report with the analysis."""
        report = []
        
        # Header
        report.append("# Vulnerability Analysis Summary")
        report.append(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        
        # 1. Contributors
        report.append("## Contributors")
        if self.contributors:
            report.extend([f"- {contrib}" for contrib in sorted(self.contributors)])
        else:
            report.append("No contributor information found.")
        report.append("")
        
        # 2. Projects and last contribution dates
        report.append("## Projects and Last Contribution Dates")
        if self.project_last_commit:
            for project, date in sorted(self.project_last_commit.items(), key=lambda x: x[1], reverse=True):
                report.append(f"- **{project}**: {date.strftime('%Y-%m-%d')}")
        else:
            report.append("No project information found.")
        report.append("")
        
        # 3. Projects with secrets
        report.append("## Projects with Secrets in Code")
        if self.secrets_found:
            for project, secrets in self.secrets_found.items():
                report.append(f"### {project}")
                report.extend([f"- {secret}" for secret in secrets])
        else:
            report.append("No secrets found in code.")
        report.append("")
        
        # 4. Top 10 vulnerable libraries
        report.append("## Top 10 Vulnerable Libraries")
        if hasattr(self, 'top_vulnerabilities') and self.top_vulnerabilities:
            report.append("| Vulnerability | Count |")
            report.append("|--------------|-------|")
            for vuln, count in self.top_vulnerabilities:
                report.append(f"| {vuln} | {count} |")
        else:
            report.append("No vulnerability data available.")
        report.append("")
        
        # 5. Top 10 remedial actions
        report.append("## Top 10 Recommended Remedial Actions")
        if self.remedial_actions:
            for i, action in enumerate(self.remedial_actions, 1):
                report.append(f"{i}. {action}")
        else:
            report.append("No specific remedial actions identified.")
        
        return "\n".join(report)

def main():
    logger.info("Starting vulnerability report analysis...")
    
    try:
        # Initialize analyzer
        analyzer = VulnerabilityAnalyzer(REPORTS_DIR)
        
        # Collect and analyze data
        logger.info("Collecting data from reports...")
        analyzer.collect_data()
        
        logger.info("Analyzing vulnerabilities...")
        analyzer.analyze_vulnerabilities()
        
        # Generate and save report
        logger.info("Generating summary report...")
        report = analyzer.generate_report()
        
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write(report)
        
        logger.info(f"Analysis complete! Report saved to {os.path.abspath(OUTPUT_FILE)}")
        print(f"\nVulnerability analysis complete! Report saved to: {os.path.abspath(OUTPUT_FILE)}")
        
    except Exception as e:
        logger.error(f"An error occurred: {str(e)}", exc_info=True)
        print(f"\nError: {str(e)}\nCheck the log file for more details: vulnerability_analysis.log")
        sys.exit(1)

if __name__ == "__main__":
    main()
